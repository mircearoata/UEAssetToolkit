#include "Toolkit/AssetTypeGenerator/MaterialGenerator.h"
#include "LandscapeGrassType.h"
#include "MaterialEditorUtilities.h"
#include "Engine/Texture.h"
#include "Engine/Texture2DArray.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "MaterialEditor/Public/MaterialEditingLibrary.h"
#include "MaterialGraph/MaterialGraphNode_Comment.h"
#include "Materials/Material.h"
#include "Materials/MaterialExpressionAdd.h"
#include "Materials/MaterialExpressionCollectionParameter.h"
#include "Materials/MaterialExpressionComment.h"
#include "Materials/MaterialExpressionConstant.h"
#include "Materials/MaterialExpressionDynamicParameter.h"
#include "Materials/MaterialExpressionLandscapeGrassOutput.h"
#include "Materials/MaterialExpressionMultiply.h"
#include "Materials/MaterialExpressionQualitySwitch.h"
#include "Materials/MaterialExpressionRuntimeVirtualTextureSampleParameter.h"
#include "Materials/MaterialExpressionScalarParameter.h"
#include "Materials/MaterialExpressionStaticSwitchParameter.h"
#include "Materials/MaterialExpressionTextureSampleParameter2D.h"
#include "Materials/MaterialExpressionTextureSampleParameterCube.h"
#include "Materials/MaterialExpressionVectorParameter.h"
#include "Materials/MaterialParameterCollection.h"
#include "Toolkit/ObjectHierarchySerializer.h"
#include "Toolkit/PropertySerializer.h"
#include "VT/RuntimeVirtualTexture.h"
#include "Engine/TextureCube.h"
#include "Materials/MaterialExpressionTextureSampleParameter2DArray.h"
#include "MediaTexture.h"
#include "Materials/MaterialExpressionFontSampleParameter.h"

static const TArray<FName> ExcludedMaterialDumpProperties = {
	//We cannot recompile game materials and add usages since we do not have their sources, so we ignore this value and force it to false
	TEXT("bAutomaticallySetUsageInEditor"),
	//Decided based on other properties and opacity input expression, recomputed every time properties are changed
	TEXT("bCanMaskedBeAssumedOpaque"),
	//Changed every time material is recompiled in editor, comparing it is pointless
	TEXT("StateId"),
	//Can be rebuild by the editor sometimes during world operations
	TEXT("TextureStreamingData"),
	//Set by material compiler automatically, cannot be set manually from the editor
	TEXT("bUsesDistortion")
};

void UMaterialGenerator::PostInitializeAssetGenerator() {
	UClass* MaterialClass = UMaterial::StaticClass();
	
	for (const FName& PropertyName : ExcludedMaterialDumpProperties) {
		GetPropertySerializer()->DisablePropertySerialization(MaterialClass, PropertyName);
	}
}

void UMaterialGenerator::CreateAssetPackage() {
	UPackage* NewPackage = CreatePackage(*GetPackageName().ToString());
	UMaterial* Material = NewObject<UMaterial>(NewPackage, GetAssetName(), RF_Public | RF_Standalone);
	SetPackageAndAsset(NewPackage, Material);

	CreateGeneratedMaterialComment(Material);
	
	FMaterialLayoutChangeInfo MaterialLayoutChangeInfo{};
	PopulateLayoutChangeInfoForNewMaterial(MaterialLayoutChangeInfo);
	PopulateMaterialWithData(Material, MaterialLayoutChangeInfo);
}

void UMaterialGenerator::OnExistingPackageLoaded() {
	UMaterial* ExistingMaterial = GetAsset<UMaterial>();

	FMaterialLayoutChangeInfo LayoutChangeInfo{};
	if (!IsMaterialUpToDate(ExistingMaterial, LayoutChangeInfo)) {
		UE_LOG(LogAssetGenerator, Log, TEXT("Refreshing asset data for Material %s"), *ExistingMaterial->GetPathName());
		PopulateMaterialWithData(ExistingMaterial, LayoutChangeInfo);
	}
}

void UMaterialGenerator::PopulateMaterialWithData(UMaterial* Asset, FMaterialLayoutChangeInfo& ChangeInfo) {
	const TSharedPtr<FJsonObject> AssetData = GetAssetData();
	const TSharedPtr<FJsonObject> AssetObjectProperties = AssetData->GetObjectField(TEXT("AssetObjectData"));
	
	//Deserialize basic properties into the material, these do not require any fix-ups
	GetObjectSerializer()->DeserializeObjectProperties(AssetObjectProperties.ToSharedRef(), Asset);
	//We cannot recompile game materials and add usages since we do not have their sources, so we ignore this value and force it to false
	Asset->bAutomaticallySetUsageInEditor = false;

	//Apply layout changes if we are capable of doing it
	TryApplyMaterialLayoutChange(Asset, ChangeInfo);
}

void UMaterialGenerator::TryApplyMaterialLayoutChange(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo) {
	bool bIsAutoGeneratedMaterialStub = false;
	bool bForceAutomaticMerge = false;
	UMaterialExpressionComment* ExistingMaterialChangelistComment = NULL;

	for (UMaterialExpressionComment* Comment : Material->GetEditorComments()) {
		if (Comment->Text.Contains("[MATERIAL CHANGELIST SUMMARY]")) {
			ExistingMaterialChangelistComment = Comment;
		} else {
			if (Comment->Text.Contains("[AUTO GENERATED MATERIAL STUB]")) {
				bIsAutoGeneratedMaterialStub = true;
			}
			if (Comment->Text.Contains("[CONFIRM AUTOMATIC MERGE]")) {;
				bForceAutomaticMerge = true;
			}
		}
	}

	const bool bCanPerformAutomaticMerge = bIsAutoGeneratedMaterialStub || bForceAutomaticMerge;
	if (bCanPerformAutomaticMerge) {
		ApplyLayoutChangelistToMaterial(Material, LayoutChangeInfo, bForceAutomaticMerge);
		
		if (ExistingMaterialChangelistComment) {
			RemoveMaterialComment(Material, ExistingMaterialChangelistComment);
		}
		MarkAssetChanged();
	} else {
		const FString ChangelistCommentText = CreateMaterialChangelistCommentText(LayoutChangeInfo);
		
		if (ExistingMaterialChangelistComment == NULL || ExistingMaterialChangelistComment->Text != ChangelistCommentText) {
			if (ExistingMaterialChangelistComment) {
				RemoveMaterialComment(Material, ExistingMaterialChangelistComment);
			}
			SpawnCommentWithText(Material, ChangelistCommentText, FVector2D(1000, 0));
			MarkAssetChanged();
		}
	}
}

PRAGMA_DISABLE_OPTIMIZATION

void UMaterialGenerator::ApplyLayoutChangelistToMaterial(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo, bool bSoftMerge) {
	RemoveOutdatedMaterialLayoutNodes(Material, LayoutChangeInfo, bSoftMerge);
	
	SpawnNewMaterialParameterNodes(Material, LayoutChangeInfo);
	ApplyMaterialParameterValueChanges(Material, LayoutChangeInfo);
	ApplyOtherLayoutChanges(Material, LayoutChangeInfo);

	CleanupStubMaterialNodes(Material);
	if (!bSoftMerge) {
		TryConnectBasicMaterialPins(Material);
		ConnectDummyParameterNodes(Material);
	}
	
	//Update cached expression data so next material generator pass will notice layout changes
	Material->UpdateCachedExpressionData();
	
	//Force material re-compilation in the update context
	ForceMaterialCompilation(Material);
}

void UMaterialGenerator::PopulateLayoutChangeInfoForNewMaterial(FMaterialLayoutChangeInfo& OutLayoutChangeInfo) const {
	const TSharedPtr<FJsonObject> AssetData = GetAssetData();
	const TSharedPtr<FJsonObject> AssetObjectProperties = AssetData->GetObjectField(TEXT("AssetObjectData"));

	const TSharedPtr<FJsonObject> CachedExpressionData = AssetData->GetObjectField(TEXT("CachedExpressionData"));
	FMaterialCachedExpressionData NewExpressionData;
	GetPropertySerializer()->DeserializeStruct(FMaterialCachedExpressionData::StaticStruct(), CachedExpressionData.ToSharedRef(), &NewExpressionData);
	
	FMaterialLayoutChangeInfo MaterialLayoutChangeInfo{};
	DetectMaterialExpressionChanges(FMaterialCachedExpressionData{}, NewExpressionData, OutLayoutChangeInfo);
}

PRAGMA_ENABLE_OPTIMIZATION

bool UMaterialGenerator::IsMaterialUpToDate(UMaterial* Asset, FMaterialLayoutChangeInfo& MaterialLayoutChangeInfo) const {
	const TSharedPtr<FJsonObject> AssetData = GetAssetData();
	const TSharedPtr<FJsonObject> AssetObjectProperties = AssetData->GetObjectField(TEXT("AssetObjectData"));

	//Material is not up-to-date if basic properties do not match with the actual game data
	if (!GetObjectSerializer()->AreObjectPropertiesUpToDate(AssetObjectProperties.ToSharedRef(), Asset)) {
		return false;
	}

	//Compare expression data manually, only textures and MPCs are relevant though
	const TSharedPtr<FJsonObject> CachedExpressionData = AssetData->GetObjectField(TEXT("CachedExpressionData"));
	FMaterialCachedExpressionData NewExpressionData;
	GetPropertySerializer()->DeserializeStruct(FMaterialCachedExpressionData::StaticStruct(), CachedExpressionData.ToSharedRef(), &NewExpressionData);

	const FMaterialCachedExpressionData& OldExpressionData = Asset->GetCachedExpressionData();
	DetectMaterialExpressionChanges(OldExpressionData, NewExpressionData, MaterialLayoutChangeInfo);

	//Material is up to date if layout change struct is empty
	return MaterialLayoutChangeInfo.IsEmpty();
}

void UMaterialGenerator::PopulateStageDependencies(TArray<FPackageDependency>& OutDependencies) const {
	if (GetCurrentStage() == EAssetGenerationStage::CONSTRUCTION) {
		const TSharedPtr<FJsonObject> AssetData = GetAssetData();
		const TSharedPtr<FJsonObject> AssetObjectProperties = AssetData->GetObjectField(TEXT("AssetObjectData"));
		const TArray<TSharedPtr<FJsonValue>> ReferencedObjects = AssetObjectProperties->GetArrayField(TEXT("$ReferencedObjects"));

		const TArray<TSharedPtr<FJsonValue>> AssetUserDataObjects = AssetObjectProperties->GetArrayField(TEXT("AssetUserData"));

		TArray<int32> AssetUserDataObjectIndices;
		for (const TSharedPtr<FJsonValue>& ObjectIndexValue : AssetUserDataObjects) {
			AssetUserDataObjectIndices.Add((int32) ObjectIndexValue->AsNumber());
		}
		
		TArray<FString> OutReferencedPackages;
		for (const TSharedPtr<FJsonValue>& ObjectIndexValue : ReferencedObjects) {
			const int32 ObjectIndex = (int32) ObjectIndexValue->AsNumber();

			if (!AssetUserDataObjectIndices.Contains(ObjectIndex)) {
				GetObjectSerializer()->CollectObjectPackages(ObjectIndex, OutReferencedPackages);
			}
		}

		TArray<TSharedPtr<FJsonValue>> ReferencedObjectsRoot = GetAssetData()->GetArrayField(TEXT("ReferencedObjects"));
		
		GetObjectSerializer()->CollectReferencedPackages(ReferencedObjectsRoot, OutReferencedPackages);
		
		for (const FString& DependencyPackageName : OutReferencedPackages) {
			OutDependencies.Add(FPackageDependency{*DependencyPackageName, EAssetGenerationStage::CDO_FINALIZATION});
		}		
	}
	
	if (GetCurrentStage() == EAssetGenerationStage::PRE_FINSHED) {
		TArray<FString> ReferencedPackages;
		const TSharedPtr<FJsonObject> AssetData = GetAssetData();
		const TSharedPtr<FJsonObject> AssetObjectProperties = AssetData->GetObjectField(TEXT("AssetObjectData"));

		const TArray<TSharedPtr<FJsonValue>> AssetUserDataObjects = AssetObjectProperties->GetArrayField(TEXT("AssetUserData"));

		for (const TSharedPtr<FJsonValue>& AssetObjectValue : AssetUserDataObjects) {
			const int32 ObjectIndex = (int32) AssetObjectValue->AsNumber();
			GetObjectSerializer()->CollectObjectPackages(ObjectIndex, ReferencedPackages);
		}
		for (const FString& PackageName : ReferencedPackages) {
			OutDependencies.Add(FPackageDependency{*PackageName, EAssetGenerationStage::CDO_FINALIZATION});	
		}
	}
}

FTopLevelAssetPath UMaterialGenerator::GetAssetClass() {
	return FTopLevelAssetPath(UMaterial::StaticClass());
}

FVector2D UMaterialGenerator::GetGoodPlaceForNewMaterialExpression(UMaterial* Material) {
	FVector2D BottomLeft(-300,-300);

	if(Material->GetExpressions().Num() > 0) {
		UMaterialExpression* Node = Material->GetExpressions()[0];
		if (Node) {
			BottomLeft = FVector2D(Node->MaterialExpressionEditorX, Node->MaterialExpressionEditorY);
			
			for (int32 i = 1; i < Material->GetExpressions().Num(); i++) {
				Node = Material->GetExpressions()[i];
				if (Node) {
					BottomLeft.X = FMath::Min<float>(BottomLeft.X, Node->MaterialExpressionEditorX);
					BottomLeft.Y = FMath::Max<float>(BottomLeft.Y, Node->MaterialExpressionEditorY);
				}
			}
		}
	}
	return BottomLeft + FVector2D(0, 256);
}

void UMaterialGenerator::ForceMaterialCompilation(UMaterial* Material) {
	FMaterialUpdateContext MaterialUpdateContext;

	MaterialUpdateContext.AddMaterial(Material);
	Material->ForceRecompileForRendering();

	Material->PreEditChange(nullptr);
	Material->PostEditChange();
}

void UMaterialGenerator::ConnectBasicParameterPinsIfPossible(UMaterial* Material, const FString& ChangelistMessage) {
	bool bIsAutoGeneratedMaterialStub = false;
	
	for (UMaterialExpressionComment* Comment : Material->GetEditorComments()) {
		if (Comment->Text.Contains("[AUTO GENERATED MATERIAL STUB]")) {
			bIsAutoGeneratedMaterialStub = true;
		}
	}

	if (bIsAutoGeneratedMaterialStub) {
		CleanupStubMaterialNodes(Material);
		TryConnectBasicMaterialPins(Material);
		ConnectDummyParameterNodes(Material);
		
	} else {
		SpawnCommentWithText(Material, ChangelistMessage, FVector2D(1400, 0));
	}
}

UClass* GetTextureSampleParameterClassForTexture(UTexture* Texture) {
	if (Texture->IsA<UTexture2D>() || Texture->IsA<UMediaTexture>()) {
		return UMaterialExpressionTextureSampleParameter2D::StaticClass();
	}
	if (Texture->IsA<UTextureCube>()) {
		return UMaterialExpressionTextureSampleParameterCube::StaticClass();
	}
	if (Texture->IsA(UTexture2DArray::StaticClass())) {
		return UMaterialExpressionTextureSampleParameter2DArray::StaticClass();
	}
	fgcheckf(0, TEXT("Unsupported Texture Class: %s"), *Texture->GetPathName());
	return NULL;
}

void UMaterialGenerator::ApplyOtherLayoutChanges(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo) {
	//Add Parameter Collection parameter nodes
	for (UMaterialParameterCollection* NewCollection : LayoutChangeInfo.NewReferencedParameterCollections) {

		for (const FCollectionScalarParameter& Parameter : NewCollection->ScalarParameters) {
			UMaterialExpressionCollectionParameter* Expression = SpawnMaterialExpression<UMaterialExpressionCollectionParameter>(Material);
			
			Expression->Collection = NewCollection;
			Expression->ParameterId = Parameter.Id;
			Expression->ParameterName = Parameter.ParameterName;
		}

		for (const FCollectionVectorParameter& Parameter : NewCollection->VectorParameters) {
			UMaterialExpressionCollectionParameter* Expression = SpawnMaterialExpression<UMaterialExpressionCollectionParameter>(Material);
			
			Expression->Collection = NewCollection;
			Expression->ParameterId = Parameter.Id;
			Expression->ParameterName = Parameter.ParameterName;
		}
	}

	UPackage* EngineScriptPackage = UEngine::StaticClass()->GetOuterUPackage();
	
	//Add Quality Level, Scene Color and Virtual Texture Output Nodes
	if (LayoutChangeInfo.bAddedQualityLevelNode) {
		SpawnMaterialExpression<UMaterialExpressionQualitySwitch>(Material);
	}
	if (LayoutChangeInfo.bAddedSceneColorExpression) {
		UClass* SceneColorExpressionClass = FindObjectChecked<UClass>(EngineScriptPackage, TEXT("MaterialExpressionSceneColor"));
		SpawnMaterialExpression<UMaterialExpression>(Material, SceneColorExpressionClass);
	}
	if (LayoutChangeInfo.bAddedVirtualTextureOutput) {
		UClass* VirtualTextureOutputExpressionClass = FindObjectChecked<UClass>(EngineScriptPackage, TEXT("MaterialExpressionRuntimeVirtualTextureOutput"));
		SpawnMaterialExpression<UMaterialExpression>(Material, VirtualTextureOutputExpressionClass);
	}

	TArray<UTexture*> AlreadyReferencedTextures;
	UMaterialExpressionLandscapeGrassOutput* LandscapeGrassOutputExpression = NULL;
	UMaterialExpressionDynamicParameter* DynamicParameterExpression = NULL;

	for (UMaterialExpression* Expression : Material->GetExpressions()) {
		if (Expression->CanReferenceTexture()) {
			UTexture* ReferencedTexture = Cast<UTexture>(Expression->GetReferencedTexture());
			if(ReferencedTexture == NULL) {
				UE_LOG(LogAssetGenerator, Log, TEXT("Material %s has a texture expression that references a null texture"), *Material->GetPathName());
				continue;
			} 
			AlreadyReferencedTextures.AddUnique(ReferencedTexture);
		}
		if (UMaterialExpressionLandscapeGrassOutput* GrassOutput = Cast<UMaterialExpressionLandscapeGrassOutput>(Expression)) {
			LandscapeGrassOutputExpression = GrassOutput;
		}
		if (UMaterialExpressionDynamicParameter* DynamicParameter = Cast<UMaterialExpressionDynamicParameter>(Expression)) {
			DynamicParameterExpression = DynamicParameter;
		}
	}

	//Add Landscape Grass Types to the existing node, or make a new one
	if (LayoutChangeInfo.NewGrassTypes.Num()) {
		if (LandscapeGrassOutputExpression == NULL) {
			LandscapeGrassOutputExpression = SpawnMaterialExpression<UMaterialExpressionLandscapeGrassOutput>(Material);
		}
		for (ULandscapeGrassType* GrassType : LayoutChangeInfo.NewGrassTypes) {
			FGrassInput NewGrassInput(GrassType->GetFName());
			NewGrassInput.GrassType = GrassType;
			LandscapeGrassOutputExpression->GrassTypes.Add(NewGrassInput);
		}
	}

	//Add Dynamic Parameters to the existing node, or make a new one
	if (LayoutChangeInfo.NewDynamicParameters.Num()) {
		if (DynamicParameterExpression == NULL) {
			DynamicParameterExpression = SpawnMaterialExpression<UMaterialExpressionDynamicParameter>(Material);
		}
		for (const FName& ParameterName : LayoutChangeInfo.NewDynamicParameters) {
			DynamicParameterExpression->ParamNames.Add(ParameterName.ToString());
		}
	}

	//Add Texture Samplers for every Texture object not referenced already
	for (UTexture* ReferencedTexture : LayoutChangeInfo.NewReferencedTextures) {
		if (!AlreadyReferencedTextures.Contains(ReferencedTexture)) {
			UMaterialExpressionTextureSample* TextureSample = SpawnMaterialExpression<UMaterialExpressionTextureSample>(Material);
			TextureSample->Texture = ReferencedTexture;
			TextureSample->AutoSetSampleType();
		}
	}
}

void UMaterialGenerator::ApplyMaterialParameterValueChanges(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo) {
	TMap<FName, UMaterialExpressionScalarParameter*> ScalarParameters;
	TMap<FName, UMaterialExpressionVectorParameter*> VectorParameters;
	TMap<FName, UMaterialExpressionTextureSampleParameter*> TextureParameters;
	TMap<FName, UMaterialExpressionFontSampleParameter*> FontParameters;
	TMap<FName, UMaterialExpressionRuntimeVirtualTextureSampleParameter*> VirtualTextureParameters;

	for (UMaterialExpression* Expression : Material->GetExpressions()) {
		if (UMaterialExpressionScalarParameter* Parameter = Cast<UMaterialExpressionScalarParameter>(Expression)) {
			ScalarParameters.Add(Parameter->ParameterName, Parameter);
		}
		if (UMaterialExpressionVectorParameter* Parameter = Cast<UMaterialExpressionVectorParameter>(Expression)) {
			VectorParameters.Add(Parameter->ParameterName, Parameter);
		}
		if (UMaterialExpressionTextureSampleParameter* Parameter = Cast<UMaterialExpressionTextureSampleParameter>(Expression)) {
			TextureParameters.Add(Parameter->ParameterName, Parameter);
		}
		if (UMaterialExpressionFontSampleParameter* Parameter = Cast<UMaterialExpressionFontSampleParameter>(Expression)) {
			FontParameters.Add(Parameter->ParameterName, Parameter);
		}
		if (UMaterialExpressionRuntimeVirtualTextureSampleParameter* Parameter = Cast<UMaterialExpressionRuntimeVirtualTextureSampleParameter>(Expression)) {
			VirtualTextureParameters.Add(Parameter->ParameterName, Parameter);
		}
	}

	for (const TParameterValueChange<float>& ScalarParameter : LayoutChangeInfo.ScalarParameterValueChanges) {
		UMaterialExpressionScalarParameter* Parameter = ScalarParameters.FindChecked(ScalarParameter.ParameterName);
		Parameter->DefaultValue = ScalarParameter.NewValue;
	}

	for (const TParameterValueChange<FLinearColor>& VectorParameter : LayoutChangeInfo.VectorParameterValueChanges) {
		UMaterialExpressionVectorParameter* Parameter = VectorParameters.FindChecked(VectorParameter.ParameterName);
		Parameter->DefaultValue = VectorParameter.NewValue;
	}
	for (const TParameterValueChange<TSoftObjectPtr<UTexture>> TextureParameter : LayoutChangeInfo.TextureParameterValueChanges) {
		UMaterialExpressionTextureSampleParameter* Parameter = TextureParameters.FindChecked(TextureParameter.ParameterName);
		Parameter->Texture = TextureParameter.NewValue.Get();
		Parameter->AutoSetSampleType();
	}
	for (const TParameterValueChange<FSimpleFontParameterValue>& FontParameter : LayoutChangeInfo.FontParameterValueChanges) {
		UMaterialExpressionFontSampleParameter* Parameter = FontParameters.FindChecked(FontParameter.ParameterName);
		Parameter->Font = FontParameter.NewValue.Font.Get();
		Parameter->FontTexturePage = FontParameter.NewValue.FontPage;
	}
	for (const TParameterValueChange<TSoftObjectPtr<URuntimeVirtualTexture>> TextureParameter : LayoutChangeInfo.VirtualTextureParameterValueChanges) {
		UMaterialExpressionRuntimeVirtualTextureSampleParameter* Parameter = VirtualTextureParameters.FindChecked(TextureParameter.ParameterName);
		Parameter->VirtualTexture = TextureParameter.NewValue.Get();
	}
}

void UMaterialGenerator::SpawnNewMaterialParameterNodes(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo) {
	//Spawn nodes for new material parameters
	for (const TMaterialParameter<float>& NewScalarParameter : LayoutChangeInfo.NewScalarParameters) {
		if (NewScalarParameter.ParameterInfo.Association == GlobalParameter) {
			UMaterialExpressionScalarParameter* Expression = SpawnMaterialExpression<UMaterialExpressionScalarParameter>(Material);
			
			Expression->SetParameterName(NewScalarParameter.ParameterInfo.Name);
			Expression->DefaultValue = NewScalarParameter.ParameterValue;
		}
	}

	for (const TMaterialParameter<FLinearColor>& NewVectorParameter : LayoutChangeInfo.NewVectorParameters) {
		if (NewVectorParameter.ParameterInfo.Association == GlobalParameter) {
			UMaterialExpressionVectorParameter* Expression = SpawnMaterialExpression<UMaterialExpressionVectorParameter>(Material);
			
			Expression->SetParameterName(NewVectorParameter.ParameterInfo.Name);
			Expression->DefaultValue = NewVectorParameter.ParameterValue;
		}
	}

	for (const TMaterialParameter<TSoftObjectPtr<UTexture>> NewTextureParameter : LayoutChangeInfo.NewTextureParameters) {
		if (NewTextureParameter.ParameterInfo.Association == GlobalParameter && NewTextureParameter.ParameterValue) {
			UClass* ExpressionClass = GetTextureSampleParameterClassForTexture(NewTextureParameter.ParameterValue.Get());
			UMaterialExpressionTextureSampleParameter* Expression = SpawnMaterialExpression<UMaterialExpressionTextureSampleParameter>(Material, ExpressionClass);
			
			Expression->SetParameterName(NewTextureParameter.ParameterInfo.Name);
			Expression->Texture = NewTextureParameter.ParameterValue.Get();
			Expression->AutoSetSampleType();
		}
	}

	for (const TMaterialParameter<FSimpleFontParameterValue>& NewFontParameter : LayoutChangeInfo.NewFontParameters) {
		if (NewFontParameter.ParameterInfo.Association == GlobalParameter) {
			UMaterialExpressionFontSampleParameter* Expression = SpawnMaterialExpression<UMaterialExpressionFontSampleParameter>(Material);
			
			Expression->SetParameterName(NewFontParameter.ParameterInfo.Name);
			Expression->Font = NewFontParameter.ParameterValue.Font.Get();
			Expression->FontTexturePage = NewFontParameter.ParameterValue.FontPage;
		}
	}

	for (const TMaterialParameter<TSoftObjectPtr<URuntimeVirtualTexture>>& NewVirtualTextureParameter : LayoutChangeInfo.NewVirtualTextureParameters) {
		if (NewVirtualTextureParameter.ParameterInfo.Association == GlobalParameter) {
			UMaterialExpressionRuntimeVirtualTextureSampleParameter* Expression = SpawnMaterialExpression<UMaterialExpressionRuntimeVirtualTextureSampleParameter>(Material);
			
			Expression->SetParameterName(NewVirtualTextureParameter.ParameterInfo.Name);
			Expression->VirtualTexture = NewVirtualTextureParameter.ParameterValue.Get();
		}
	}
}


void UMaterialGenerator::RemoveOutdatedMaterialLayoutNodes(UMaterial* Material, FMaterialLayoutChangeInfo& LayoutChangeInfo, bool bOnlyRemoveParameterNodes) {
	//Remove all expressions that need to be removed first
	TArray<UMaterialExpression*> ExpressionsToRemove;
	
	for (UMaterialExpression* Expression : Material->GetExpressions()) {

		//HANDLE REMOVED PARAMETERS FIRST AND THEIR RELEVANT EXPRESSIONS
		if (Expression->IsA<UMaterialExpressionScalarParameter>() || Expression->IsA<UMaterialExpressionVectorParameter>()) {
			UMaterialExpressionParameter* ParameterExpression = CastChecked<UMaterialExpressionParameter>(Expression);
			
			if (LayoutChangeInfo.IsParameterNodeRemoved(ParameterExpression->ParameterName)) {
				ExpressionsToRemove.Add(Expression);
			}
		}
		
		if (UMaterialExpressionTextureSampleParameter* TextureSampleParameter = Cast<UMaterialExpressionTextureSampleParameter>(Expression)) {
			if (LayoutChangeInfo.IsParameterNodeRemoved(TextureSampleParameter->ParameterName)) {
				ExpressionsToRemove.Add(Expression);
			}
		}
		
		if (UMaterialExpressionFontSampleParameter* FontSampleParameter = Cast<UMaterialExpressionFontSampleParameter>(Expression)) {
			if (LayoutChangeInfo.IsParameterNodeRemoved(FontSampleParameter->ParameterName)) {
				ExpressionsToRemove.Remove(Expression);
			}
		}
		
		if (UMaterialExpressionRuntimeVirtualTextureSampleParameter* Parameter = Cast<UMaterialExpressionRuntimeVirtualTextureSampleParameter>(Expression)) {
			if (LayoutChangeInfo.IsParameterNodeRemoved(Parameter->ParameterName)) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		//HANDLE REMOVED DYNAMIC PARAMETERS
		if (UMaterialExpressionDynamicParameter* DynamicParameter = Cast<UMaterialExpressionDynamicParameter>(Expression)) {
			DynamicParameter->ParamNames.RemoveAll([&](const FString& ParameterName) {
				const FName ParameterFName = *ParameterName;
				return LayoutChangeInfo.RemovedDynamicParameters.Contains(ParameterFName);
			});
			if (DynamicParameter->ParamNames.Num() == 0) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		//HANDLE REMOVED GRASS TYPES
		if (UMaterialExpressionLandscapeGrassOutput* GrassOutput = Cast<UMaterialExpressionLandscapeGrassOutput>(Expression)) {
			GrassOutput->GrassTypes.RemoveAll([&](const FGrassInput& GrassInput) {
					return LayoutChangeInfo.RemovedGrassTypes.Contains(GrassInput.GrassType);
				});
			//Keep the node during soft merge since even if it's empty, it's most likely connected with something
			if (GrassOutput->GrassTypes.Num() == 0 && !bOnlyRemoveParameterNodes) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		//Remove unreferenced parameter collection parameters, but keep them during soft merge
		if (UMaterialExpressionCollectionParameter* CollectionParameter = Cast<UMaterialExpressionCollectionParameter>(Expression)) {
			if (LayoutChangeInfo.RemovedParameterCollections.Contains(CollectionParameter->Collection) && !bOnlyRemoveParameterNodes) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		//Remove any expressions referencing textures that are no longer referenced, but keep them if we're doing soft merge
		if (Expression->CanReferenceTexture() && !bOnlyRemoveParameterNodes) {
			UObject* ReferencedTexture = Expression->GetReferencedTexture();
			bool IsParameterChanged = LayoutChangeInfo.TextureParameterValueChanges.ContainsByPredicate([Expression](const TParameterValueChange<TSoftObjectPtr<UTexture>>& ParameterValueChange) {
				return ParameterValueChange.ParameterName == Expression->GetParameterName();
			});
			if (ReferencedTexture && LayoutChangeInfo.NoLongerReferencedTextures.Contains(ReferencedTexture) && !IsParameterChanged) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		//Remove various nodes we know whenever are used or not, but only during hard merges (since they don't affect API)
		if (Expression->IsA<UMaterialExpressionQualitySwitch>()) {
			if (LayoutChangeInfo.bRemovedQualityLevelNode && !bOnlyRemoveParameterNodes) {
				ExpressionsToRemove.Add(Expression);
			}
		}

		UPackage* EngineScriptPackage = UEngine::StaticClass()->GetOuterUPackage();
		
		UClass* SceneColorExpressionClass = FindObjectChecked<UClass>(EngineScriptPackage, TEXT("MaterialExpressionSceneColor"));
		UClass* VirtualTextureOutputExpressionClass = FindObjectChecked<UClass>(EngineScriptPackage, TEXT("MaterialExpressionRuntimeVirtualTextureOutput"));
		
		if (Expression->IsA(SceneColorExpressionClass)) {
			if (LayoutChangeInfo.bRemovedSceneColorExpression && !bOnlyRemoveParameterNodes) {
				ExpressionsToRemove.Add(Expression);
			}
		}
		if (Expression->IsA(VirtualTextureOutputExpressionClass)) {
			if (LayoutChangeInfo.bRemovedVirtualTextureOutput && !bOnlyRemoveParameterNodes) {
				ExpressionsToRemove.Add(Expression);
			}
		}
	}

	for (UMaterialExpression* RemovedExpression : ExpressionsToRemove) {
		// Removing an expression from the material does not unlink the connections, so we need to do that manually
		// However, the Multiply nodes are not in the ExpressionCollection
		// so the only way to reach them is through the material input expression references
		// Is there any better way to do this? Is the generator missing something that would add the Multiply nodes?
		FExpressionInput& BaseColorInput = Material->GetEditorOnlyData()->BaseColor;
		FExpressionInput& NormalInput = Material->GetEditorOnlyData()->Normal;
		FExpressionInput& RoughnessInput = Material->GetEditorOnlyData()->Roughness;

		TQueue<FExpressionInput*> InputsToCheck;
		InputsToCheck.Enqueue(&BaseColorInput);
		InputsToCheck.Enqueue(&NormalInput);
		InputsToCheck.Enqueue(&RoughnessInput);

		TSet<UMaterialExpression*> CheckedExpressions;

		while(!InputsToCheck.IsEmpty()) {
			FExpressionInput* Input;
			InputsToCheck.Dequeue(Input);

			if (!Input) continue;

			if (!Input->IsConnected()) continue;

			if (!CheckedExpressions.Contains(Input->Expression)) {
				CheckedExpressions.Add(Input->Expression);
				for (FExpressionInput* ExpressionInput : Input->Expression->GetInputs()) {
					InputsToCheck.Enqueue(ExpressionInput);
				}
			}
			
			if (Input->Expression == RemovedExpression) {
				Input->Expression = NULL;
			}
		}
		
		Material->RemoveExpressionParameter(RemovedExpression);

		Material->GetExpressionCollection().RemoveExpression(RemovedExpression);
		if (RemovedExpression->GraphNode) {
			FBlueprintEditorUtils::RemoveNode(NULL, RemovedExpression->GraphNode, true);
		}
	}
}

void UMaterialGenerator::CleanupStubMaterialNodes(UMaterial* Material) {
	for (int32 i = Material->GetExpressions().Num() - 1; i >= 0; i--) {
		UMaterialExpression* Expression = Material->GetExpressions()[i];
		if (Expression->Desc.StartsWith(TEXT("[STUB NODE]"))) {
			if (Expression->IsRooted()) {
				// I have no idea why, but these might be rooted.
				// Couldn't get the debugger to stop on AddToRoot() either.
				Expression->RemoveFromRoot();
			}
			UMaterialEditingLibrary::DeleteMaterialExpression(Material, Expression);
			if (Expression->GraphNode) {
				FBlueprintEditorUtils::RemoveNode(NULL, Expression->GraphNode, true);
			}
		}
	}
}

void DisconnectIfExpressionMissing(FExpressionInput& Input, UMaterial* Material) {
	if (Input.Expression && !Material->GetExpressions().Contains(Input.Expression)) {
		Input.Expression = nullptr;
	}
}

void UMaterialGenerator::TryConnectBasicMaterialPins(UMaterial* Material) {
	FExpressionInput& BaseColorInput = Material->GetEditorOnlyData()->BaseColor;
	FExpressionInput& NormalInput = Material->GetEditorOnlyData()->Normal;

	DisconnectIfExpressionMissing(BaseColorInput, Material);
	DisconnectIfExpressionMissing(NormalInput, Material);
	
	for (UMaterialExpression* Expression : Material->GetExpressions()) {
		if (UMaterialExpressionTextureSample* TextureSample = Cast<UMaterialExpressionTextureSample>(Expression)) {
			if ((TextureSample->SamplerType == SAMPLERTYPE_Color || TextureSample->SamplerType == SAMPLERTYPE_LinearColor) && !BaseColorInput.IsConnected()) {
				BaseColorInput.Connect(0, TextureSample);
			}
			else if (TextureSample->SamplerType == SAMPLERTYPE_Normal && !NormalInput.IsConnected()) {
				NormalInput.Connect(0, TextureSample);
			}
		}
	}
}

PRAGMA_DISABLE_OPTIMIZATION

void UMaterialGenerator::ConnectDummyParameterNodes(UMaterial* Material) {
	if (Material->GetEditorOnlyData()->Roughness.IsConnected()) {
		return;
	}
	
	TArray<UMaterialExpression*> AllParameters;
	TArray<UMaterialExpressionStaticSwitchParameter*> StaticSwitchParameters;

	for (UMaterialExpression* Expression : Material->GetExpressions()) {
		if (UMaterialExpressionTextureSampleParameter* TextureSampleParameter = Cast<UMaterialExpressionTextureSampleParameter>(Expression)) {
			AllParameters.Add(TextureSampleParameter);
		}
		if (UMaterialExpressionFontSampleParameter* FontSampleParameter = Cast<UMaterialExpressionFontSampleParameter>(Expression)) {
			AllParameters.Add(FontSampleParameter);
		}
		if (UMaterialExpressionRuntimeVirtualTextureSampleParameter* VirtualTextureSampleParameter = Cast<UMaterialExpressionRuntimeVirtualTextureSampleParameter>(Expression)) {
			AllParameters.Add(VirtualTextureSampleParameter);
		}
		if (UMaterialExpressionScalarParameter* ScalarParameter = Cast<UMaterialExpressionScalarParameter>(Expression)) {
			AllParameters.Add(ScalarParameter);
		}
		if (UMaterialExpressionVectorParameter* VectorParameter = Cast<UMaterialExpressionVectorParameter>(Expression)) {
			AllParameters.Add(VectorParameter);
		}
		if (UMaterialExpressionStaticSwitchParameter* StaticSwitchParameter = Cast<UMaterialExpressionStaticSwitchParameter>(Expression)) {
			AllParameters.Add(StaticSwitchParameter);
			StaticSwitchParameters.Add(StaticSwitchParameter);
		}
	}

	for (UMaterialExpressionStaticSwitchParameter* StaticSwitchParameter : StaticSwitchParameters) {
		UMaterialExpressionConstant* ExpressionConstant = SpawnMaterialExpression<UMaterialExpressionConstant>(Material);

		StaticSwitchParameter->A.Connect(0, ExpressionConstant);
		StaticSwitchParameter->B.Connect(0, ExpressionConstant);

		ExpressionConstant->Desc = TEXT("[STUB NODE] Stub just to get static switch node connected and showing up in child material instances");
	}

	int32 ParameterIndex = 0;
	UMaterialExpression* LastAddExpression = NULL;

	if (AllParameters.Num()) {
		LastAddExpression = AllParameters[ParameterIndex];
		ParameterIndex++;
	}

	for (int32 i = ParameterIndex; i < AllParameters.Num(); i++) {
		UMaterialExpressionMultiply* ExpressionMultiply = SpawnMaterialExpression<UMaterialExpressionMultiply>(Material);
		
		ExpressionMultiply->A.Connect(0, LastAddExpression);
		ExpressionMultiply->B.Connect(0, AllParameters[i]);
		
		ExpressionMultiply->Desc = TEXT("[STUB NODE] Stub just to get parameters connected and showing up in child material instances");

		LastAddExpression = ExpressionMultiply;
	}

	if (LastAddExpression != NULL) {
		UMaterialExpressionMultiply* ZeroMultiply = SpawnMaterialExpression<UMaterialExpressionMultiply>(Material);
		ZeroMultiply->A.Connect(0, LastAddExpression);
		ZeroMultiply->ConstB = 0.0f;
		ZeroMultiply->Desc = TEXT("[STUB NODE] Stub just to get parameters connected and showing up in child material instances");

		Material->GetEditorOnlyData()->Roughness.Connect(0, ZeroMultiply);
	}
}

PRAGMA_ENABLE_OPTIMIZATION

void UMaterialGenerator::CreateGeneratedMaterialComment(UMaterial* Material) {
	FString ResultCommentText;
	ResultCommentText.Append(TEXT("[AUTO GENERATED MATERIAL STUB]\n"));
	ResultCommentText.Append(TEXT("This material is an auto generated stub for the game material with the same name.\n"));
	
	ResultCommentText.Append(TEXT("Stub materials contain minimal information about real material's implementation, \n"));
	ResultCommentText.Append(TEXT("like Material Parameters, Used Textures and Parameter Collections, \n"));
	ResultCommentText.Append(TEXT("but that information is automatically brought up to date.\n"));
	
	ResultCommentText.Append(TEXT("If you're willing to make any changes to the material, REMOVE THAT COMMENT,\n"));
	ResultCommentText.Append(TEXT("Or your changes might be overwritten in the future\n"));

	SpawnCommentWithText(Material, ResultCommentText, FVector2D(300, 0));
}

FString UMaterialGenerator::CreateMaterialChangelistCommentText(const FMaterialLayoutChangeInfo& ChangeInfo) {
	FString ResultCommentText;
	ResultCommentText.Append(TEXT("[MATERIAL CHANGELIST SUMMARY]"));
	ResultCommentText.Append(TEXT("This material appears to have been manually edited, and because of that\n"));
	ResultCommentText.Append(TEXT("automatic stub update is not possible.\n"));
	
	ResultCommentText.Append(TEXT("Here is the summary of changes that appeared in the game material,\n"));
	ResultCommentText.Append(TEXT("compared to the current version of the material: "));

	ResultCommentText.Append(TEXT("Apply these changes manually using the material editor,\n"));
	ResultCommentText.Append(TEXT("Or create new comment with text [CONFIRM AUTOMATIC MERGE] and re-run asset generation\n"));
	ResultCommentText.Append(TEXT("to apply changes automatically. Keep in mind that automatic changes will likely\n"));
	ResultCommentText.Append(TEXT("result in material breaking visually or not compiling at all!\n"));

	ResultCommentText.Append(TEXT("\n"));

	TArray<FString> ChangelistLines;
	ChangeInfo.PrintChangeReport(ChangelistLines);
	ResultCommentText += FString::Join(ChangelistLines, TEXT("\n"));
	return ResultCommentText;
}

void UMaterialGenerator::SpawnCommentWithText(UMaterial* Material, const FString& CommentText, const FVector2D& NodePos) {
	UMaterialExpressionComment* NewComment = NewObject<UMaterialExpressionComment>(Material, NAME_None, RF_Transactional);
	NewComment->Text = CommentText;

	NewComment->MaterialExpressionEditorX = NodePos.X;
	NewComment->MaterialExpressionEditorY = NodePos.Y;
	NewComment->SizeX = 600;
	NewComment->SizeY = 400;
		
	Material->GetEditorOnlyData()->ExpressionCollection.AddComment(NewComment);
	if (Material->MaterialGraph) {
		Material->MaterialGraph->AddComment(NewComment, false);
	}
}

void UMaterialGenerator::RemoveMaterialComment(UMaterial* Material, UMaterialExpressionComment* Comment) {
	if (Comment->GraphNode) {
		FBlueprintEditorUtils::RemoveNode(NULL, Comment->GraphNode, true);
	}

	Material->GetExpressionCollection().RemoveComment(Comment);
}

void UMaterialGenerator::DetectMaterialExpressionChanges(const FMaterialCachedExpressionData& OldData, const FMaterialCachedExpressionData& NewData, FMaterialLayoutChangeInfo& ChangeInfo) {
	
	TSet<FName> AllParameterNames;
	TMap<FName, FIndexedParameterInfo> OldParameters;
	TMap<FName, FIndexedParameterInfo> NewParameters;
	
	
	const FMaterialCachedParameterEntry* OldEntryArray = OldData.RuntimeEntries;
	const FMaterialCachedParameterEntry* NewEntryArray = NewData.RuntimeEntries;
	
	for (int32 ParameterTypeRaw = 0; ParameterTypeRaw < NumMaterialRuntimeParameterTypes; ParameterTypeRaw++) {
		
		EMaterialParameterType ParameterType = (EMaterialParameterType) ParameterTypeRaw;
		
		const FMaterialCachedParameterEntry& OldParameterEntry = OldEntryArray[ParameterTypeRaw];
		const FMaterialCachedParameterEntry& NewParameterEntry = NewEntryArray[ParameterTypeRaw];

		for (const FMaterialParameterInfo& ParameterInfo : OldParameterEntry.ParameterInfoSet) {
			OldParameters.Add(ParameterInfo.Name, {ParameterInfo, ParameterType, OldParameterEntry.ParameterInfoSet.FindId(ParameterInfo).AsInteger()});
			AllParameterNames.Add(ParameterInfo.Name);
		}

		for (const FMaterialParameterInfo& ParameterInfo : NewParameterEntry.ParameterInfoSet) {
			NewParameters.Add(ParameterInfo.Name, {ParameterInfo, ParameterType, NewParameterEntry.ParameterInfoSet.FindId(ParameterInfo).AsInteger()});
			AllParameterNames.Add(ParameterInfo.Name);
		}
	}

	for (const FName& ParameterName : AllParameterNames) {
		FIndexedParameterInfo* OldParameterInfo = OldParameters.Find(ParameterName);
		FIndexedParameterInfo* NewParameterInfo = NewParameters.Find(ParameterName);

		if (OldParameterInfo != NULL && NewParameterInfo != NULL) {
			if (OldParameterInfo->ParameterType != NewParameterInfo->ParameterType ||
				OldParameterInfo->ParameterInfo.Association != NewParameterInfo->ParameterInfo.Association ||
				OldParameterInfo->ParameterInfo.Index != NewParameterInfo->ParameterInfo.Index) {

				//Parameter has changed too drastically to announce it as value change, so remove it and add back
				ChangeInfo.RemovedMaterialParameters.Add(OldParameterInfo->ParameterInfo);
				AddNewParameterInfo(NewData, NewParameterInfo->ParameterIndex, NewParameterInfo->ParameterType, NewParameterInfo->ParameterInfo, ChangeInfo);

			} else {
				CompareParameterValues(OldData, NewData, OldParameterInfo->ParameterIndex, NewParameterInfo->ParameterIndex, NewParameterInfo->ParameterType, ParameterName, ChangeInfo);
			}
			
		} else if (OldParameterInfo == NULL) {
			AddNewParameterInfo(NewData, NewParameterInfo->ParameterIndex, NewParameterInfo->ParameterType, NewParameterInfo->ParameterInfo, ChangeInfo);

		} else if (NewParameterInfo == NULL) {
			ChangeInfo.RemovedMaterialParameters.Add(OldParameterInfo->ParameterInfo);
		}
	}

	for (UObject* Element : NewData.ReferencedTextures) {
		UTexture* Texture = Cast<UTexture>(Element);
		if (Texture && !OldData.ReferencedTextures.Contains(Texture)) {
			ChangeInfo.NewReferencedTextures.Add(Texture);
		}
	}
	for (UObject* Element : OldData.ReferencedTextures) {
		UTexture* Texture = Cast<UTexture>(Element);
		if (Texture && !NewData.ReferencedTextures.Contains(Texture)) {
			ChangeInfo.NoLongerReferencedTextures.Add(Texture);
		}
	}

	for (const FName& Element : NewData.DynamicParameterNames) {
		if (!OldData.DynamicParameterNames.Contains(Element)) {
			ChangeInfo.NewDynamicParameters.Add(Element);
		}
	}
	for (const FName& Element : OldData.DynamicParameterNames) {
		if (!NewData.DynamicParameterNames.Contains(Element)) {
			ChangeInfo.RemovedDynamicParameters.Add(Element);
		}
	}
	
	for (ULandscapeGrassType* Element : NewData.GrassTypes) {
		if (!OldData.GrassTypes.Contains(Element)) {
			ChangeInfo.NewGrassTypes.Add(Element);
		}
	}
	for (ULandscapeGrassType* Element : OldData.GrassTypes) {
		if (!NewData.GrassTypes.Contains(Element)) {
			ChangeInfo.RemovedGrassTypes.Add(Element);
		}
	}

	TArray<UMaterialParameterCollection*> OldReferencedCollections;
	TArray<UMaterialParameterCollection*> NewReferencedCollections;

	for (const FMaterialParameterCollectionInfo& ParameterCollectionInfo : OldData.ParameterCollectionInfos) {
		OldReferencedCollections.Add(ParameterCollectionInfo.ParameterCollection);
	}
	for (const FMaterialParameterCollectionInfo& ParameterCollectionInfo : NewData.ParameterCollectionInfos) {
		NewReferencedCollections.Add(ParameterCollectionInfo.ParameterCollection);
	}

	for (UMaterialParameterCollection* Element : NewReferencedCollections) {
		if (!OldReferencedCollections.Contains(Element)) {
			ChangeInfo.NewReferencedParameterCollections.Add(Element);
		}
	}
	for (UMaterialParameterCollection* Element : OldReferencedCollections) {
		if (!NewReferencedCollections.Contains(Element)) {
			ChangeInfo.RemovedParameterCollections.Add(Element);
		}
	}

	if (OldData.bHasSceneColor != NewData.bHasSceneColor) {
		if (OldData.bHasSceneColor) {
			ChangeInfo.bRemovedSceneColorExpression = true;
		} else if (NewData.bHasSceneColor) {
			ChangeInfo.bAddedSceneColorExpression = true;
		}
	}

	if (OldData.bHasRuntimeVirtualTextureOutput != NewData.bHasRuntimeVirtualTextureOutput) {
		if (OldData.bHasRuntimeVirtualTextureOutput) {
			ChangeInfo.bRemovedVirtualTextureOutput = true;
		} else if (NewData.bHasRuntimeVirtualTextureOutput) {
			ChangeInfo.bAddedVirtualTextureOutput = true;
		}
	}

	const bool bOldHasQualityLevel = IsMaterialQualityNodeUsed(OldData);
	const bool bNewHasQualityLevel = IsMaterialQualityNodeUsed(NewData);

	if (bOldHasQualityLevel != bNewHasQualityLevel) {
		if (bOldHasQualityLevel) {
			ChangeInfo.bRemovedQualityLevelNode = true;
		} else if (bNewHasQualityLevel) {
			ChangeInfo.bAddedQualityLevelNode = true;
		}
	}
}

//UMaterialExpressionQualitySwitch is used when either of Low/Medium QualityLevel parameters are not false, or High one is false
//High will always be set by default when no quality nodes are present
bool UMaterialGenerator::IsMaterialQualityNodeUsed(const FMaterialCachedExpressionData& Data) {
	if (Data.QualityLevelsUsed.Num() != 3) {
		return false;
	}
	if (Data.QualityLevelsUsed[EMaterialQualityLevel::Low] || Data.QualityLevelsUsed[EMaterialQualityLevel::Medium]) {
		return true;
	}
	if (!Data.QualityLevelsUsed[EMaterialQualityLevel::High]) {
		return true;
	}
	return false;
}

void UMaterialGenerator::AddNewParameterInfo(const FMaterialCachedExpressionData& Data, int32 Index, EMaterialParameterType Type, const FMaterialParameterInfo& ParameterInfo, FMaterialLayoutChangeInfo& ChangeInfo) {
	if (Type == EMaterialParameterType::Scalar) {
		const float Value = Data.ScalarValues[Index];
		ChangeInfo.NewScalarParameters.Add({ParameterInfo, Value});
	}
	else if (Type == EMaterialParameterType::Vector) {
		FLinearColor Value = Data.VectorValues[Index];
		ChangeInfo.NewVectorParameters.Add({ParameterInfo, Value});
	}
	else if (Type == EMaterialParameterType::Texture) {
		TSoftObjectPtr<UTexture> Value = Data.TextureValues[Index];
		ChangeInfo.NewTextureParameters.Add({ParameterInfo, Value});
	}
	else if (Type == EMaterialParameterType::Font) {
		TSoftObjectPtr<UFont> Font = Data.FontValues[Index];
		ChangeInfo.NewFontParameters.Add({ParameterInfo, Font});
	}
	else if (Type == EMaterialParameterType::RuntimeVirtualTexture) {
		TSoftObjectPtr<URuntimeVirtualTexture> Texture = Data.RuntimeVirtualTextureValues[Index];
		ChangeInfo.NewVirtualTextureParameters.Add({ParameterInfo, Texture});
	}
}

void UMaterialGenerator::CompareParameterValues(const FMaterialCachedExpressionData& OldData, const FMaterialCachedExpressionData& NewData, int32 IndexOld, int32 IndexNew, EMaterialParameterType Type, FName ParameterName, FMaterialLayoutChangeInfo& ChangeInfo) {
	if (Type == EMaterialParameterType::Scalar) {
		float OldValue = OldData.ScalarValues[IndexOld];
		float NewValue = NewData.ScalarValues[IndexNew];

		if (FMath::Abs(OldValue - NewValue) >= KINDA_SMALL_NUMBER) {
			ChangeInfo.ScalarParameterValueChanges.Add({ParameterName, OldValue, NewValue});
		}
	}
	else if (Type == EMaterialParameterType::Vector) {
		FLinearColor OldValue = OldData.VectorValues[IndexOld];
		FLinearColor NewValue = NewData.VectorValues[IndexNew];

		if (!OldValue.Equals(NewValue, KINDA_SMALL_NUMBER)) {
			ChangeInfo.VectorParameterValueChanges.Add({ParameterName, OldValue, NewValue});
		}
	}
	else if (Type == EMaterialParameterType::Texture) {
		TSoftObjectPtr<UTexture> OldValue = OldData.TextureValues[IndexOld];
		TSoftObjectPtr<UTexture> NewValue = NewData.TextureValues[IndexNew];

		if (OldValue != NewValue) {
			ChangeInfo.TextureParameterValueChanges.Add({ParameterName, OldValue, NewValue});
		}
	}
	else if (Type == EMaterialParameterType::Font) {
		TSoftObjectPtr<UFont> OldFont = OldData.FontValues[IndexOld];
		TSoftObjectPtr<UFont> NewFont = NewData.FontValues[IndexNew];

		int32 OldFontPage = OldData.FontPageValues[IndexOld];
		int32 NewFontPage = NewData.FontPageValues[IndexNew];

		if (OldFont != NewFont || OldFontPage != NewFontPage) {
			const FSimpleFontParameterValue OldValue{OldFont, OldFontPage};
			const FSimpleFontParameterValue NewValue{NewFont, NewFontPage};
			
			ChangeInfo.FontParameterValueChanges.Add({ParameterName, OldValue, NewValue});
		}
	}
	else if (Type == EMaterialParameterType::RuntimeVirtualTexture) {
		TSoftObjectPtr<URuntimeVirtualTexture> OldTexture = OldData.RuntimeVirtualTextureValues[IndexOld];
		TSoftObjectPtr<URuntimeVirtualTexture> NewTexture = NewData.RuntimeVirtualTextureValues[IndexNew];

		if (OldTexture != NewTexture) {
			ChangeInfo.VirtualTextureParameterValueChanges.Add({ParameterName, OldTexture, NewTexture});
		}	
	}
}

FString ParameterInfoToString(const FMaterialParameterInfo& ParameterInfo) {
	FString ResultString;

	ResultString += ParameterInfo.Name.ToString();
	ResultString.Append(TEXT(" ("));

	UEnum* AssociationEnum = StaticEnum<EMaterialParameterAssociation>();
	ResultString += AssociationEnum->GetNameByValue(ParameterInfo.Association).ToString();

	if (ParameterInfo.Index != INDEX_NONE) {
		ResultString.Append(TEXT(", Index = "));
		ResultString.AppendInt(ParameterInfo.Index);
	}
	ResultString.AppendChar(')');
	return ResultString;
}

void FMaterialLayoutChangeInfo::PrintChangeReport(TArray<FString>& OutReport) const {
	if (RemovedMaterialParameters.Num()) {
		OutReport.Add(TEXT("Removed Material Parameters:"));
		for (const FMaterialParameterInfo& ParameterInfo : RemovedMaterialParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *ParameterInfoToString(ParameterInfo)));
		}
	}
	
	if (NewScalarParameters.Num()) {
		OutReport.Add(TEXT("New Scalar Parameters:"));
		for (const TMaterialParameter<float>& Parameter : NewScalarParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s = %f"), *ParameterInfoToString(Parameter.ParameterInfo), Parameter.ParameterValue));
		}
	}
	if (NewVectorParameters.Num()) {
		OutReport.Add(TEXT("New Vector Parameters:"));
		for (const TMaterialParameter<FLinearColor>& Parameter : NewVectorParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s = %s"), *ParameterInfoToString(Parameter.ParameterInfo), *Parameter.ParameterValue.ToString()));
		}
	}
	if (NewTextureParameters.Num()) {
		OutReport.Add(TEXT("New Texture Parameters:"));
		for (const TMaterialParameter<TSoftObjectPtr<UTexture>>& Parameter : NewTextureParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s = %s"), *ParameterInfoToString(Parameter.ParameterInfo), *Parameter.ParameterValue->GetPathName()));
		}
	}
	if (NewFontParameters.Num()) {
		OutReport.Add(TEXT("New Font Parameters:"));
		for (const TMaterialParameter<FSimpleFontParameterValue>& Parameter : NewFontParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s = %s"), *ParameterInfoToString(Parameter.ParameterInfo), *Parameter.ParameterValue.ToString()));
		}
	}
	if (NewVirtualTextureParameters.Num()) {
		OutReport.Add(TEXT("New Runtime Virtual Texture Parameters:"));
		for (const TMaterialParameter<TSoftObjectPtr<URuntimeVirtualTexture>>& Parameter : NewVirtualTextureParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s = %s"), *ParameterInfoToString(Parameter.ParameterInfo), *Parameter.ParameterValue->GetPathName()));
		}
	}

	if (ScalarParameterValueChanges.Num()) {
		OutReport.Add(TEXT("Scalar Parameter Value Changes:"));
		for (const TParameterValueChange<float>& Parameter : ScalarParameterValueChanges) {
			OutReport.Add(FString::Printf(TEXT(" - %s: %f -> %f (Old -> New)"), *Parameter.ParameterName.ToString(), Parameter.OldValue, Parameter.NewValue));
		}
	}
	if (VectorParameterValueChanges.Num()) {
		OutReport.Add(TEXT("Vector Parameter Value Changes:"));
		for (const TParameterValueChange<FLinearColor>& Parameter : VectorParameterValueChanges) {
			OutReport.Add(FString::Printf(TEXT(" - %s: %s -> %s (Old -> New)"), *Parameter.ParameterName.ToString(), *Parameter.OldValue.ToString(), *Parameter.NewValue.ToString()));
		}
	}
	if (TextureParameterValueChanges.Num()) {
		OutReport.Add(TEXT("Texture Parameter Value Changes:"));
		for (const TParameterValueChange<TSoftObjectPtr<UTexture>>& Parameter : TextureParameterValueChanges) {
			OutReport.Add(FString::Printf(TEXT(" - %s: %s -> %s (Old -> New)"), *Parameter.ParameterName.ToString(), *Parameter.OldValue->GetPathName(), *Parameter.NewValue->GetPathName()));
		}
	}
	if (FontParameterValueChanges.Num()) {
		OutReport.Add(TEXT("Font Parameter Value Changes:"));
		for (const TParameterValueChange<FSimpleFontParameterValue>& Parameter : FontParameterValueChanges) {
			OutReport.Add(FString::Printf(TEXT(" - %s: %s -> %s (Old -> New)"), *Parameter.ParameterName.ToString(), *Parameter.OldValue.ToString(), *Parameter.NewValue.ToString()));
		}
	}
	if (VirtualTextureParameterValueChanges.Num()) {
		OutReport.Add(TEXT("Font Parameter Value Changes:"));
		for (const TParameterValueChange<TSoftObjectPtr<URuntimeVirtualTexture>>& Parameter : VirtualTextureParameterValueChanges) {
			OutReport.Add(FString::Printf(TEXT(" - %s: %s -> %s (Old -> New)"), *Parameter.ParameterName.ToString(), *Parameter.OldValue->GetPathName(), *Parameter.NewValue->GetPathName()));
		}
	}

	if (NewReferencedParameterCollections.Num()) {
		OutReport.Add(TEXT("New Referenced Parameter Collections:"));
		for (UMaterialParameterCollection* ParameterCollection : NewReferencedParameterCollections) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *ParameterCollection->GetPathName()));
		}
	}
	if (RemovedParameterCollections.Num()) {
		OutReport.Add(TEXT("Parameter Collections No Longer Referenced:"));
		for (UMaterialParameterCollection* ParameterCollection : RemovedParameterCollections) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *ParameterCollection->GetPathName()));
		}
	}

	if (bAddedQualityLevelNode) {
		OutReport.Add(TEXT(" - Added Material Quality Switch"));
	}
	if (bRemovedQualityLevelNode) {
		OutReport.Add(TEXT(" - Removed Material Quality Switch"));
	}
	if (bAddedSceneColorExpression) {
		OutReport.Add(TEXT(" - Added Scene Color Material Node"));
	}
	if (bRemovedSceneColorExpression) {
		OutReport.Add(TEXT(" - Removed Scene Color Material Node"));
	}
	if (bAddedVirtualTextureOutput) {
		OutReport.Add(TEXT(" - Added Virtual Texture Output Node"));
	}
	if (bRemovedVirtualTextureOutput) {
		OutReport.Add(TEXT(" - Removed Virtual Texture Output Node"));
	}

	if (NewGrassTypes.Num()) {
		OutReport.Add("Grass Types Added:");
		for (ULandscapeGrassType* GrassType : NewGrassTypes) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *GrassType->GetPathName()));
		}
	}
	if (RemovedGrassTypes.Num()) {
		OutReport.Add("Grass Types Removed:");
		for (ULandscapeGrassType* GrassType : RemovedGrassTypes) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *GrassType->GetPathName()));
		}
	}

	if (NewDynamicParameters.Num()) {
		OutReport.Add(TEXT("New Dynamic Parameters:"));
		for (const FName& DynamicParameterName : NewDynamicParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *DynamicParameterName.ToString()));
		}
	}
	if (RemovedDynamicParameters.Num()) {
		OutReport.Add(TEXT("Dynamic Parameters Removed:"));
		for (const FName& DynamicParameterName : RemovedDynamicParameters) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *DynamicParameterName.ToString()));
		}
	}

	if (NewReferencedTextures.Num()) {
		OutReport.Add(TEXT("New Referenced Textures: "));
		for (UTexture* Texture : NewReferencedTextures) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *Texture->GetPathName()));
		}
	}
	if (NoLongerReferencedTextures.Num()) {
		OutReport.Add(TEXT("Textures No Longer Referenced: "));
		for (UTexture* Texture : NoLongerReferencedTextures) {
			OutReport.Add(FString::Printf(TEXT(" - %s"), *Texture->GetPathName()));
		}
	}
}

bool FMaterialLayoutChangeInfo::IsParameterNodeRemoved(const FName& ParameterName) {
	for (const FMaterialParameterInfo& ParameterInfo : RemovedMaterialParameters) {
		if (ParameterInfo.Name == ParameterName && ParameterInfo.Association == GlobalParameter) {
			return true;
		}
	}
	return false;
}

bool FMaterialLayoutChangeInfo::IsEmpty() const {
	return  this->RemovedMaterialParameters.Num() == 0 &&
			this->NewScalarParameters.Num() == 0 &&
			this->NewVectorParameters.Num() == 0 &&
			this->NewTextureParameters.Num() == 0 &&
			this->NewFontParameters.Num() == 0 &&
			this->NewVirtualTextureParameters.Num() == 0 &&
				
			this->ScalarParameterValueChanges.Num() == 0 &&
			this->VectorParameterValueChanges.Num() == 0 &&
			this->TextureParameterValueChanges.Num() == 0 &&
			this->FontParameterValueChanges.Num() == 0 &&
			this->VirtualTextureParameterValueChanges.Num() == 0 &&

			this->NewReferencedParameterCollections.Num() == 0 &&
			this->RemovedParameterCollections.Num() == 0 &&
				
			this->bAddedQualityLevelNode == false &&
			this->bRemovedQualityLevelNode == false &&
				
			this->bAddedSceneColorExpression == false &&
			this->bRemovedSceneColorExpression == false &&
				
			this->bAddedVirtualTextureOutput == false &&
			this->bRemovedVirtualTextureOutput == false &&

			this->NewGrassTypes.Num() == 0 &&
			this->RemovedGrassTypes.Num() == 0 &&
				
			this->NewDynamicParameters.Num() == 0 &&
			this->RemovedDynamicParameters.Num() == 0 &&

			this->NewReferencedTextures.Num() == 0 &&
			this->NoLongerReferencedTextures.Num() == 0;
}
